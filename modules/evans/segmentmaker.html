

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>evans.segmentmaker &mdash; Perllan API 0.3 documentation</title>
  

  
  <link rel="stylesheet" href="../../static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="../../static/abjad.css" type="text/css" />
  <link rel="stylesheet" href="../../static/uqbar.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../static/notes.ico"/>
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../static/documentation_options.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../static/documentation_options.js"></script>
        <script src="../../static/jquery.js"></script>
        <script src="../../static/underscore.js"></script>
        <script src="../../static/doctools.js"></script>
        <script defer="defer" src="../../static/copybutton.js"></script>
        <script src="../../static/ga.js"></script>
    
    <script type="text/javascript" src="../../static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #556B2F" >
          

          
            <a href="../../index.html" class="icon icon-home" alt="Documentation Home"> Perllan API
          

          
            
            <img src="../../static/perllan-logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../concepts.html">Core concepts</a></li>
</ul>
<p class="caption"><span class="caption-text">Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api/abjadext/microtones/index.html">microtones</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/evans/index.html">evans</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/tsmakers/index.html">tsmakers</a></li>
</ul>
<p class="caption"><span class="caption-text">Examples</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../scores.html">Score gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../recipes_pitch.html">Pitch Recipes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../recipes_sequence.html">Sequence Recipes</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../glossary.html">Glossary</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Perllan API</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content style-external-links">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>evans.segmentmaker</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for evans.segmentmaker</h1><div class="highlight"><pre>
<span></span>&quot;&quot;&quot;
SegmentMaker with supporting classes and functions.
&quot;&quot;&quot;
import datetime
import itertools
import os

import abjad
import baca
import quicktions

from . import consort
from .commands import HandlerCommand, RhythmCommand
from .sequence import flatten


<div class="viewcode-block" id="NoteheadBracketMaker"><a class="viewcode-back" href="../../api/evans/segmentmaker.html#evans.segmentmaker.NoteheadBracketMaker">[docs]</a>class NoteheadBracketMaker:
    r&quot;&quot;&quot;
    Writes tuplet brackets with inserted note head.

    .. container:: example

        &gt;&gt;&gt; tuplet = abjad.Tuplet((3, 2), &quot;cs&#39;8 d&#39;8&quot;)
        &gt;&gt;&gt; tuplet_2 = abjad.Tuplet((2, 3), components=[abjad.Note(0, (3, 8)), tuplet])
        &gt;&gt;&gt; staff = abjad.Staff()
        &gt;&gt;&gt; staff.append(tuplet_2)
        &gt;&gt;&gt; staff.extend([abjad.Note(&quot;c&#39;4&quot;), abjad.Note(&quot;cs&#39;8&quot;), abjad.Note(&quot;d&#39;8&quot;)])
        &gt;&gt;&gt; new_brackets = evans.NoteheadBracketMaker()
        &gt;&gt;&gt; new_brackets(staff)
        &gt;&gt;&gt; score = abjad.Score([staff])
        &gt;&gt;&gt; moment = &quot;#(ly:make-moment 1 25)&quot;
        &gt;&gt;&gt; abjad.setting(score).proportional_notation_duration = moment
        &gt;&gt;&gt; file = abjad.LilyPondFile(
        ...     items=[score],
        ...     includes=[&quot;abjad.ily&quot;],
        ...     global_staff_size=16,
        ... )
        ...
        &gt;&gt;&gt; abjad.show(file) # doctest: +SKIP

        .. docs::

            &gt;&gt;&gt; print(abjad.lilypond(staff))
            \new Staff
            {
                \tweak TupletNumber.text #(tuplet-number::append-note-wrapper(tuplet-number::non-default-tuplet-fraction-text 3 2) &quot;4&quot;)
                \times 2/3 {
                    c&#39;4.
                    \tweak text #tuplet-number::calc-fraction-text
                    \tweak TupletNumber.text #(tuplet-number::append-note-wrapper(tuplet-number::non-default-tuplet-fraction-text 2 3) &quot;8&quot;)
                    \times 3/2 {
                        cs&#39;8
                        d&#39;8
                    }
                }
                c&#39;4
                cs&#39;8
                d&#39;8
            }

    &quot;&quot;&quot;

<div class="viewcode-block" id="NoteheadBracketMaker.__call__"><a class="viewcode-back" href="../../api/evans/segmentmaker.html#evans.segmentmaker.NoteheadBracketMaker.__call__">[docs]</a>    def __call__(self, selections):
        return self._transform_brackets(selections)</div>

<div class="viewcode-block" id="NoteheadBracketMaker.__str__"><a class="viewcode-back" href="../../api/evans/segmentmaker.html#evans.segmentmaker.NoteheadBracketMaker.__str__">[docs]</a>    def __str__(self):
        return abjad.storage(self)</div>

<div class="viewcode-block" id="NoteheadBracketMaker.__repr__"><a class="viewcode-back" href="../../api/evans/segmentmaker.html#evans.segmentmaker.NoteheadBracketMaker.__repr__">[docs]</a>    def __repr__(self):
        return abjad.storage(self)</div>

    def _assemble_notehead(self, head_dur):
        pair = head_dur.pair
        dot_parts = []
        while 1 &lt; pair[0]:
            dot_part = (1, pair[1])
            dot_parts.append(dot_part)
            head_dur -= abjad.Duration(dot_part)
            pair = head_dur.pair
        duration_string = f&quot;{pair[1]}&quot;
        for _ in dot_parts:
            duration_string += &quot;.&quot;
        return duration_string

    def _transform_brackets(self, selections):
        for tuplet in abjad.select(selections).components(abjad.Tuplet):
            for rest_group in abjad.select(tuplet).rests().group_by_contiguity():
                abjad.mutate.fuse(rest_group)
            inner_durs = []
            for _ in tuplet[:]:
                if isinstance(_, abjad.Tuplet):
                    inner_durs.append(_.multiplied_duration)
                else:
                    inner_durs.append(_.written_duration)
            tuplet_dur = sum(inner_durs)
            imp_num, imp_den = tuplet.implied_prolation.pair
            head_dur = tuplet_dur / imp_den
            dur_string = self._assemble_notehead(head_dur)
            abjad.tweak(
                tuplet
            ).TupletNumber.text = f&#39;#(tuplet-number::append-note-wrapper(tuplet-number::non-default-tuplet-fraction-text {imp_den} {imp_num}) &quot;{dur_string}&quot;)&#39;</div>


<div class="viewcode-block" id="SegmentMaker"><a class="viewcode-back" href="../../api/evans/segmentmaker.html#evans.segmentmaker.SegmentMaker">[docs]</a>class SegmentMaker:

    beaming = False

    def __init__(
        self,
        abbreviations=None,
        add_final_grand_pause=True,
        barline=&quot;||&quot;,
        beam_pattern=&quot;runs&quot;,
        beam_rests=False,
        clef_handlers=None,
        colophon=None,
        commands=None,
        current_directory=None,
        cutaway=True,
        fermata=&quot;scripts.ushortfermata&quot;,
        instruments=None,
        names=None,
        name_staves=True,
        mm_rests=True,
        page_break_counts=None,
        rehearsal_mark=None,
        score_includes=None,
        score_template=None,
        segment_name=None,
        tempo=((1, 4), 90),
        time_signatures=None,
        tuplet_bracket_noteheads=True,
    ):
        self.abbreviations = abbreviations
        self.add_final_grand_pause = add_final_grand_pause
        self.barline = barline
        self.beam_pattern = beam_pattern
        SegmentMaker.beaming = beam_rests
        self.clef_handlers = clef_handlers
        self.colophon = colophon
        self.commands = commands
        self.current_directory = current_directory
        self.cutaway = cutaway
        self.fermata = fermata
        self.instruments = instruments
        self.names = names
        self.name_staves = name_staves
        self.mm_rests = mm_rests
        self.page_break_counts = page_break_counts
        self.rehearsal_mark = rehearsal_mark
        self.score_includes = score_includes
        self.score_template = score_template
        self.segment_name = segment_name
        self.tempo = tempo
        self.time_signatures = time_signatures
        self.tuplet_bracket_noteheads = tuplet_bracket_noteheads

<div class="viewcode-block" id="SegmentMaker.__str__"><a class="viewcode-back" href="../../api/evans/segmentmaker.html#evans.segmentmaker.SegmentMaker.__str__">[docs]</a>    def __str__(self):
        return abjad.storage(self)</div>

<div class="viewcode-block" id="SegmentMaker.__repr__"><a class="viewcode-back" href="../../api/evans/segmentmaker.html#evans.segmentmaker.SegmentMaker.__repr__">[docs]</a>    def __repr__(self):
        return abjad.storage(self)</div>

    def _add_attachments(self):
        print(&quot;Adding attachments ...&quot;)
        if self.colophon is not None:
            last_voice = abjad.select(self.score_template).components(abjad.Voice)[
                -1
            ]  #
            colophon_leaf = abjad.select(last_voice).leaves()[-2]  #
            abjad.attach(self.colophon, colophon_leaf)

        if self.abbreviations is not None:
            abbreviations = []
            abb = self.abbreviations
            mark_abbreviations = [
                abjad.Markup(fr&quot;\markup {{ \hcenter-in #12 {_} }}&quot;, literal=True)
                for _ in abb
            ]
            for x in mark_abbreviations:
                abbreviations.append(abjad.MarginMarkup(markup=x))
        else:
            abbreviations = [_ for _ in range(len(self.instruments))]
        if self.names is not None:
            names = []
            nm = self.names
            mark_names = [
                abjad.Markup(fr&quot;\markup {{ \hcenter-in #14 {_} }}&quot;, literal=True)
                for _ in nm
            ]
            for x in mark_names:
                names.append(abjad.StartMarkup(markup=x))
        else:
            names = [_ for _ in range(len(self.instruments))]

        metro = abjad.MetronomeMark(self.tempo[0], self.tempo[1])
        # metro = abjad.MetronomeMark(custom_markup=metro.make_tempo_equation_markup())#remove if broken
        if self.tempo is not None:
            for staff in abjad.iterate(
                self.score_template[&quot;Global Context&quot;]
            ).components(abjad.Staff):
                leaf1 = abjad.select(staff).leaves()[0]
                abjad.attach(metro, leaf1)

        markup2 = abjad.RehearsalMark(
            markup=abjad.Markup(
                fr&quot;\markup \bold {{ {self.rehearsal_mark} }}&quot;, literal=True
            )
        )
        if self.rehearsal_mark is not None:
            for staff in abjad.iterate(
                self.score_template[&quot;Global Context&quot;]
            ).components(abjad.Staff):
                leaf1 = abjad.select(staff).leaves()[0]
                abjad.attach(markup2, leaf1)

        bar_line = abjad.BarLine(self.barline)
        if self.barline is not None:
            for voice in abjad.iterate(self.score_template[&quot;Staff Group&quot;]).components(
                abjad.Staff  # was Voice
            ):
                if self.barline == &quot;|.&quot;:
                    last_leaf = abjad.select(voice).leaves()[-1]
                    abjad.attach(bar_line, last_leaf)
                else:
                    last_leaf = abjad.select(voice).leaves()[-3]
                    abjad.attach(bar_line, last_leaf)

        if self.clef_handlers is None:
            self.clef_handlers = [
                None
                for _ in abjad.select(self.score_template[&quot;Staff Group&quot;]).components(
                    abjad.Staff
                )
            ]
        for abbrev, name, inst, handler, voice in zip(
            abbreviations,
            names,
            self.instruments,
            self.clef_handlers,
            abjad.select(self.score_template[&quot;Staff Group&quot;]).components(
                abjad.Staff
            ),  # was Voice
        ):
            first_leaf = abjad.select(voice).leaves()[0]
            if self.name_staves is True:
                if not isinstance(abbrev, int):
                    abjad.attach(
                        abbrev,
                        first_leaf,
                        tag=abjad.Tag(&quot;applying staff names and clefs&quot;),
                    )
                if not isinstance(name, int):
                    abjad.attach(
                        name,
                        first_leaf,
                        tag=abjad.Tag(&quot;applying staff names and clefs&quot;),
                    )
            abjad.attach(
                inst, first_leaf, tag=abjad.Tag(&quot;applying staff names and clefs&quot;)
            )
            # abjad.iterpitches.transpose_from_sounding_pitch(voice)
            if handler is not None:
                handler(voice)

    def _add_ending_skips(self):
        print(&quot;Adding ending skips ...&quot;)
        last_skip = abjad.select(self.score_template[&quot;Global Context&quot;]).leaves()[-1]
        override_command = abjad.LilyPondLiteral(
            r&quot;\once \override Score.TimeSignature.stencil = ##f&quot;, format_slot=&quot;before&quot;
        )
        abjad.attach(
            override_command, last_skip, tag=abjad.Tag(&quot;applying ending skips&quot;)
        )

        for voice in abjad.select(self.score_template[&quot;Staff Group&quot;]).components(
            abjad.Voice
        ):
            container = abjad.Container()
            sig = self.time_signatures[-1]
            leaf_duration = sig.duration / 2
            rest_leaf = abjad.Rest(1, multiplier=(leaf_duration))
            mult_rest_leaf = abjad.MultimeasureRest(1, multiplier=(leaf_duration))
            container.append(rest_leaf)
            container.append(mult_rest_leaf)
            markup = abjad.Markup(
                rf&quot;&quot;&quot;\markup \center-align \musicglyph #&quot;{self.fermata}&quot; &quot;&quot;&quot;,
                direction=abjad.Up,
                literal=True,
            )
            start_command = abjad.LilyPondLiteral(
                r&quot;\stopStaff \once \override Staff.StaffSymbol.line-count = #0 \startStaff&quot;,
                format_slot=&quot;before&quot;,
            )
            stop_command = abjad.LilyPondLiteral(
                r&quot;\stopStaff \startStaff&quot;, format_slot=&quot;after&quot;
            )
            rest_literal = abjad.LilyPondLiteral(
                r&quot;\once \override Rest.color = #white&quot;, &quot;before&quot;
            )
            mult_rest_literal = abjad.LilyPondLiteral(
                r&quot;\once \override MultiMeasureRest.color = #white&quot;, &quot;before&quot;
            )
            penultimate_rest = container[0]
            final_rest = container[-1]
            abjad.attach(markup, final_rest, tag=abjad.Tag(&quot;applying ending skips&quot;))
            abjad.attach(
                start_command, penultimate_rest, tag=abjad.Tag(&quot;applying ending skips&quot;)
            )
            if self.barline == &quot;|.&quot;:
                stop_command = abjad.LilyPondLiteral(r&quot;\stopStaff&quot;, format_slot=&quot;after&quot;)
                abjad.attach(
                    stop_command, final_rest, tag=abjad.Tag(&quot;applying ending skips&quot;)
                )
            else:
                abjad.attach(
                    stop_command, final_rest, tag=abjad.Tag(&quot;applying ending skips&quot;)
                )
            abjad.attach(
                rest_literal, penultimate_rest, tag=abjad.Tag(&quot;applying ending skips&quot;)
            )
            abjad.attach(
                mult_rest_literal, final_rest, tag=abjad.Tag(&quot;applying ending skips&quot;)
            )
            voice.append(container[:])

<div class="viewcode-block" id="SegmentMaker.beam_score"><a class="viewcode-back" href="../../api/evans/segmentmaker.html#evans.segmentmaker.SegmentMaker.beam_score">[docs]</a>    def beam_score(target):
        global_skips = [_ for _ in abjad.select(target[&quot;Global Context&quot;]).leaves()]
        sigs = []
        for skip in global_skips:
            for indicator in abjad.get.indicators(skip):
                if isinstance(indicator, abjad.TimeSignature):
                    sigs.append(indicator)
        print(&quot;Beaming meter ...&quot;)
        for voice in abjad.iterate(target[&quot;Staff Group&quot;]).components(abjad.Voice):
            for i, shard in enumerate(abjad.mutate.split(voice[:], sigs)):
                met = abjad.Meter(sigs[i].pair)
                inventories = [
                    x
                    for x in enumerate(
                        abjad.Meter(sigs[i].pair).depthwise_offset_inventory
                    )
                ]
                if sigs[i].denominator == 4:
                    beam_meter(
                        components=shard[:],
                        meter=met,
                        offset_depth=inventories[-1][0],
                        include_rests=SegmentMaker.beaming,
                        # include_rests=False,
                    )
                else:
                    beam_meter(
                        components=shard[:],
                        meter=met,
                        offset_depth=inventories[-2][0],
                        include_rests=SegmentMaker.beaming,
                        # include_rests=False,
                    )
        for trem in abjad.select(target).components(abjad.TremoloContainer):
            if abjad.StartBeam() in abjad.get.indicators(trem[0]):
                abjad.detach(abjad.StartBeam(), trem[0])
            if abjad.StopBeam() in abjad.get.indicators(trem[-1]):
                abjad.detach(abjad.StopBeam(), trem[-1])</div>

    def _break_pages(self):
        print(&quot;Breaking pages ...&quot;)
        if self.page_break_counts is not None:
            lit = abjad.LilyPondLiteral(r&quot;\pageBreak&quot;, format_slot=&quot;absolute_after&quot;)
            result = abjad.select(self.score_template[&quot;Global Context&quot;]).components(
                abjad.Skip
            )
            result = result.partition_by_counts(
                self.page_break_counts, cyclic=True, overhang=False
            )

            for item in result:
                abjad.attach(lit, item[-1])

    def _cache_persistent_info(self):
        print(&quot;Caching persistent info ...&quot;)
        info = abjad.OrderedDict()
        for i, voice in enumerate(
            abjad.select(self.score_template[&quot;Staff Group&quot;]).components(
                abjad.Staff
            )  # was Voice
        ):
            penultimate_rest = abjad.select(voice).leaves()[-2]
            persistent_attachments = abjad.get.indicators(penultimate_rest)
            info[f&quot;Voice {i + 1}&quot;] = persistent_attachments
        with open(f&quot;{self.current_directory}/.persistent.py&quot;, &quot;w&quot;) as fp:
            info_format = abjad.storage(info)
            string = f&quot;import abjad\ninfo = {info_format}&quot;
            fp.writelines(string)

    def _call_commands(self):
        if self.commands is None:
            return
        print(&quot;Calling commands ...&quot;)
        self.commands = flatten(self.commands)
        for group_type, group in itertools.groupby(self.commands, lambda _: type(_)):
            if group_type == RhythmCommand:
                rhythm_group = [_ for _ in group]
                self._make_containers(rhythm_group)
            elif group_type == HandlerCommand:
                handler_group = [_ for _ in group]
                self.call_handlers(handler_group)
            elif group_type == str:
                for s in group:
                    if s == &quot;skips&quot;:
                        self._add_ending_skips()
            else:
                for command in group:
                    command(self.score_template)

<div class="viewcode-block" id="SegmentMaker.call_handlers"><a class="viewcode-back" href="../../api/evans/segmentmaker.html#evans.segmentmaker.SegmentMaker.call_handlers">[docs]</a>    def call_handlers(self, commands):  # bypasses grace notes?
        print(&quot;Calling handlers ...&quot;)
        handler_to_value = abjad.OrderedDict()
        voice_names = sorted(set(_.voice_name for _ in commands))
        command_groups = []
        for handler_type, command_group in itertools.groupby(
            commands, lambda _: type(_.handler)
        ):
            group = [_ for _ in command_group]
            command_groups.append(group)
        for group in command_groups:
            voice_collections = abjad.OrderedDict()
            global_collection = consort.LogicalTieCollection()
            for tie in abjad.select(
                self.score_template[&quot;Global Context&quot;]
            ).logical_ties():
                global_collection.insert(tie)
            voice_collections[&quot;Global Context&quot;] = global_collection
            for voice in abjad.select(self.score_template).components(abjad.Voice):
                collection = consort.LogicalTieCollection()
                for tie in abjad.select(voice).logical_ties():
                    collection.insert(tie)
                voice_collections[voice.name] = collection
            for v_name in voice_names:
                voice_command_list = [
                    command for command in group if command.voice_name == v_name
                ]
                voice_command_list.sort(key=lambda _: _.timespan)
                for command in voice_command_list:
                    voice_tie_collection = voice_collections[command.voice_name]
                    target_timespan = command.timespan
                    selection = abjad.Selection(
                        [
                            _
                            for _ in voice_tie_collection.find_logical_ties_starting_during_timespan(
                                target_timespan
                            )
                        ]
                    )
                    if not selection:
                        continue
                    handler = command.handler
                    handler(selection)
                    handler_to_value[handler.name] = handler.state()
        with open(f&quot;{self.current_directory}/.handlers.py&quot;, &quot;w&quot;) as fp:
            handler_to_value_format = abjad.storage(handler_to_value)
            string = f&quot;import abjad\nhandler_to_value = {handler_to_value_format}&quot;
            fp.writelines(string)</div>

    def _extract_parts(self):
        print(&quot;Extracting parts ...&quot;)
        for count, staff in enumerate(
            abjad.iterate(self.score_template[&quot;Staff Group&quot;]).components(abjad.Staff)
        ):
            t = rf&quot;\tag #&#39;voice{count + 1}&quot;
            literal = abjad.LilyPondLiteral(t, format_slot=&quot;before&quot;)
            container = abjad.Container()
            abjad.attach(literal, container)
            abjad.mutate.wrap(staff, container)
        for count, group in enumerate(
            abjad.iterate(self.score_template[&quot;Staff Group&quot;]).components(
                abjad.StaffGroup
            )
        ):
            t = rf&quot;\tag #&#39;group{count + 1}&quot;
            literal = abjad.LilyPondLiteral(t, format_slot=&quot;before&quot;)
            container = abjad.Container()
            abjad.attach(literal, container)
            abjad.mutate.wrap(group, container)

    def _make_global_context(self):
        print(&quot;Making global context ...&quot;)

        for time_signature in self.time_signatures:
            skip = abjad.Skip(1, multiplier=(time_signature))
            abjad.attach(time_signature, skip, tag=abjad.Tag(&quot;scaling time signatures&quot;))
            self.score_template[&quot;Global Context&quot;].append(skip)

    def _make_containers(self, commands):
        print(&quot;Making containers ...&quot;)

        def make_container(handler, durations):
            selections = handler(durations)
            container = abjad.Container([])
            container.extend(selections)
            return container

        voice_names = sorted(set(_.voice_name for _ in commands))
        handler_to_value = abjad.OrderedDict()
        for voice_name in voice_names:
            voice_commands = [_ for _ in commands if _.voice_name == voice_name]
            voice_commands.sort(key=lambda _: _.timespan)
            for handler, grouper in itertools.groupby(
                voice_commands, key=lambda _: _.handler
            ):
                durations = [command.timespan.duration for command in grouper]
                container = make_container(handler, durations)
                voice = self.score_template[voice_name]
                voice.append(container[:])
                handler_to_value[handler.name] = handler.return_state()
        with open(f&quot;{self.current_directory}/.rhythm.py&quot;, &quot;w&quot;) as fp:
            handler_to_value_format = abjad.storage(handler_to_value)
            string = f&quot;import abjad\nhandler_to_value = {handler_to_value_format}&quot;
            fp.writelines(string)

    def _make_mm_rests(self):
        print(&quot;Making MM rests ...&quot;)
        for voice in abjad.iterate(self.score_template[&quot;Staff Group&quot;]).components(
            abjad.Staff  # was Voice
        ):
            leaves = abjad.select(voice).leaves(grace=False)
            shards = abjad.mutate.split(leaves, self.time_signatures)
            for shard in shards[:-1]:
                if not all(isinstance(leaf, abjad.Rest) for leaf in shard):
                    continue
                indicators = abjad.get.indicators(shard[0])
                multiplier = abjad.get.duration(shard) / 2
                invisible_rest = abjad.Rest(1, multiplier=(multiplier))
                rest_literal = abjad.LilyPondLiteral(
                    r&quot;\once \override Rest.transparent = ##t&quot;, &quot;before&quot;
                )
                abjad.attach(
                    rest_literal, invisible_rest, tag=abjad.Tag(&quot;applying invisibility&quot;)
                )
                for indicator in indicators:
                    abjad.attach(
                        indicator, invisible_rest, tag=abjad.Tag(&quot;applying indicators&quot;)
                    )
                multimeasure_rest = abjad.MultimeasureRest(1, multiplier=(multiplier))
                start_command = abjad.LilyPondLiteral(
                    r&quot;\stopStaff \once \override Staff.StaffSymbol.line-count = #1 \startStaff&quot;,
                    format_slot=&quot;before&quot;,
                )
                stop_command = abjad.LilyPondLiteral(
                    r&quot;\stopStaff \startStaff&quot;, format_slot=&quot;after&quot;
                )
                if self.cutaway is True:
                    abjad.attach(
                        start_command, invisible_rest, tag=abjad.Tag(&quot;applying cutaway&quot;)
                    )
                    abjad.attach(
                        stop_command,
                        multimeasure_rest,
                        tag=abjad.Tag(&quot;applying cutaway&quot;),
                    )
                    both_rests = [invisible_rest, multimeasure_rest]
                    abjad.mutate.replace(shard, both_rests[:])
                else:
                    both_rests = [invisible_rest, multimeasure_rest]
                    abjad.mutate.replace(shard, both_rests[:])

    def _remove_final_grand_pause(self):
        if self.add_final_grand_pause is True:
            return
        print(&quot;Removing final grand pause ...&quot;)
        for staff in abjad.select(self.score_template[&quot;Global Context&quot;]).components(
            abjad.Staff
        ):
            grand_pause = abjad.mutate.split(staff[:], self.time_signatures)[-1]
            for _ in grand_pause:
                staff.remove(_)
        for voice in abjad.select(self.score_template[&quot;Staff Group&quot;]).components(
            abjad.Voice
        ):
            grand_pause = abjad.mutate.split(voice[:], self.time_signatures)[-1]
            for _ in grand_pause:
                voice.remove(_)

    def _render_file(self):
        print(&quot;Rendering file ...&quot;)
        abjad.SegmentMaker.comment_measure_numbers(self.score_template)
        score_block = abjad.Block(name=&quot;score&quot;)
        score_block.items.append(self.score_template)
        score_file = abjad.LilyPondFile(
            items=[score_block], includes=self.score_includes
        )
        for leaf in abjad.iterate(self.score_template).leaves():
            literal = abjad.LilyPondLiteral(&quot;&quot;, &quot;absolute_before&quot;)
            abjad.attach(literal, leaf, tag=None)
        for container in abjad.iterate(self.score_template).components(abjad.Container):
            if hasattr(container, &quot;_main_leaf&quot;):
                literal = abjad.LilyPondLiteral(&quot;&quot;, &quot;absolute_after&quot;)
                abjad.attach(literal, container, tag=None)
            else:
                literal = abjad.LilyPondLiteral(&quot;&quot;, &quot;absolute_before&quot;)
                abjad.attach(literal, container, tag=None)
            literal = abjad.LilyPondLiteral(&quot;&quot;, &quot;closing&quot;)
            abjad.attach(literal, container, tag=None)
        directory = self.current_directory
        pdf_path = baca.Path(f&quot;{directory}/illustration.pdf&quot;)
        if pdf_path.exists():
            pdf_path.unlink()
        print(f&quot;Persisting {pdf_path.trim()} ...&quot;)
        result = abjad.persist.as_pdf(
            score_file,
            pdf_path,
            # align_tags=79,
        )
        success = result[3]
        if success is False:
            print(&quot;LilyPond failed!&quot;)
        if pdf_path.exists():
            print(f&quot;Opening {pdf_path.trim()} ...&quot;)
            os.system(f&quot;open {pdf_path}&quot;)
        with open(f&quot;{directory}/illustration.ly&quot;) as pointer_1:
            score_lines = pointer_1.readlines()
            build_path = self.current_directory.parent.with_name(&quot;build&quot;)
            build_path /= &quot;score&quot;
            lines = score_lines[7:-1]  # was 15:-1
            with open(f&quot;{build_path}/{self.segment_name}.ly&quot;, &quot;w&quot;) as fp:
                fp.writelines(lines)

<div class="viewcode-block" id="SegmentMaker.rewrite_meter"><a class="viewcode-back" href="../../api/evans/segmentmaker.html#evans.segmentmaker.SegmentMaker.rewrite_meter">[docs]</a>    def rewrite_meter(target):
        print(&quot;Rewriting meter ...&quot;)
        global_skips = [_ for _ in abjad.select(target[&quot;Global Context&quot;]).leaves()]
        sigs = []
        for skip in global_skips:
            for indicator in abjad.get.indicators(skip):
                if isinstance(indicator, abjad.TimeSignature):
                    sigs.append(indicator)
        for voice in abjad.select(target[&quot;Staff Group&quot;]).components(abjad.Voice):
            voice_dur = abjad.get.duration(voice)
            time_signatures = sigs[:-1]
            durations = [_.duration for _ in time_signatures]
            sig_dur = sum(durations)
            assert voice_dur == sig_dur, (voice_dur, sig_dur)
            shards = abjad.mutate.split(voice[:], durations)
            for i, shard in enumerate(shards):
                time_signature = sigs[i]
                inventories = [
                    x
                    for x in enumerate(
                        abjad.Meter(time_signature.pair).depthwise_offset_inventory
                    )
                ]
                if time_signature.denominator == 4:
                    abjad.Meter.rewrite_meter(
                        shard,
                        time_signature,
                        boundary_depth=inventories[-1][0],
                        rewrite_tuplets=False,
                    )
                else:
                    abjad.Meter.rewrite_meter(
                        shard,
                        time_signature,
                        boundary_depth=inventories[-2][0],
                        rewrite_tuplets=False,
                    )</div>

<div class="viewcode-block" id="SegmentMaker.transform_brackets"><a class="viewcode-back" href="../../api/evans/segmentmaker.html#evans.segmentmaker.SegmentMaker.transform_brackets">[docs]</a>    def transform_brackets(target):
        print(&quot;Transforming brackets ...&quot;)
        for tuplet in abjad.select(target).components(abjad.Tuplet):
            if tuplet.multiplier.pair[1] % tuplet.multiplier.pair[0] &gt; 1:
                if tuplet.diminution() is True:
                    tuplet.toggle_prolation()
            if tuplet.multiplier.pair[0] % tuplet.multiplier.pair[1] &gt; 1:
                if tuplet.augmentation() is True:
                    tuplet.toggle_prolation()
            tuplet.normalize_multiplier()
            if tuplet.trivializable() is True:
                tuplet.trivialize()
            if tuplet.trivial() is True:
                tuplet.hide = True
            if abjad.get.sustained(tuplet) is True:
                inner_durs = []
                for _ in tuplet[:]:
                    if isinstance(_, abjad.Tuplet):
                        inner_durs.append(_.multiplied_duration)
                    else:
                        inner_durs.append(_.written_duration)
                tuplet_dur = sum(inner_durs)
                imp_num, imp_den = tuplet.implied_prolation.pair
                head_dur = tuplet_dur / imp_den
                dur = head_dur * imp_num
                maker = abjad.NoteMaker()
                donor_leaves = maker([0], [dur])
                indicators = abjad.get.indicators(tuplet[0])
                for indicator in indicators:
                    abjad.attach(indicator, donor_leaves[-1])
                abjad.mutate.replace(tuplet, donor_leaves[:])
            if tuplet.rest_filled() is True:
                inner_durs = []
                for _ in tuplet[:]:
                    if isinstance(_, abjad.Tuplet):
                        inner_durs.append(_.multiplied_duration)
                    else:
                        inner_durs.append(_.written_duration)
                tuplet_dur = sum(inner_durs)
                imp_num, imp_den = tuplet.implied_prolation.pair
                head_dur = tuplet_dur / imp_den
                dur = head_dur * imp_num
                maker = abjad.NoteMaker()
                abjad.mutate.replace(tuplet, maker([None], [dur]))
            if tuplet.hide is not True:
                notehead_maker = NoteheadBracketMaker()
                notehead_maker(tuplet)</div>

    def _write_optimization_log(self):
        print(&quot;Writing optimization log ...\n&quot;)
        times = [self.pre_handlers_time + self.handlers_time + self.post_handlers_time]
        segment_time = sum(times)
        with open(f&quot;{self.current_directory}/.optimization&quot;, &quot;a&quot;) as fp:

            segment_time = f&quot;Segment runtime: {segment_time} &quot;
            segment_time += abjad.String(&quot;second&quot;).pluralize(segment_time)

            pre_handlers_time = f&quot; Pre-handlers runtime: {self.pre_handlers_time} &quot;
            pre_handlers_time += abjad.String(&quot;second&quot;).pluralize(
                self.pre_handlers_time
            )

            handlers_time = f&quot; Handlers runtime: {self.handlers_time} &quot;
            handlers_time += abjad.String(&quot;second&quot;).pluralize(self.handlers_time)

            post_handlers_time = f&quot; Post-handlers runtime: {self.post_handlers_time} &quot;
            post_handlers_time += abjad.String(&quot;second&quot;).pluralize(
                self.post_handlers_time
            )

            lines = []
            lines.append(&quot;&quot;)
            lines.append(&quot;&quot;)
            lines.append(f&quot;{datetime.datetime.now().strftime(&#39;%Y-%m-%d %H:%M:%S&#39;)}&quot;)
            lines.append(segment_time)
            lines.append(pre_handlers_time)
            lines.append(handlers_time)
            lines.append(post_handlers_time)
            string = &quot;\n&quot;.join(lines)
            fp.write(string)

    ## EXPERIMENTAL

    def _extract_voice_info(self, score):
        score_pitches = []
        score_durations = []
        for voice in abjad.select(score).components(abjad.Voice):
            pitches = []
            durations = []
            for tie in abjad.select(voice).logical_ties():
                dur = abjad.get.duration(tie)
                durations.append(str(dur))
                if isinstance(tie[0], abjad.Rest):
                    sub_pitches = [&quot;Rest()&quot;]
                else:
                    if abjad.get.annotation(tie[0], &quot;ratio&quot;):
                        sub_pitches = [abjad.get.annotation(tie[0], &quot;ratio&quot;)]
                    else:
                        sub_pitches = [p.hertz for p in abjad.get.pitches(tie[0])]
                if 1 &lt; len(sub_pitches):
                    pitches.append([str(s) for s in sub_pitches])
                elif 0 == len(sub_pitches):
                    pitches.append(&quot;Rest()&quot;)
                else:
                    pitches.append(str(sub_pitches[0]))
            score_pitches.append(pitches)
            score_durations.append(durations)
        return [_ for _ in zip(score_pitches, score_durations)]

    def _make_sc_file(self):
        info = self._extract_voice_info(self.score_template)
        lines = &quot;s.boot;\ns.quit;\n\n(&quot;

        for i, voice in enumerate(info):
            lines += f&quot;\n\t// voice {i + 1}\n\t\tPbind(\n\t\t\t\\freq, Pseq(\n&quot;

            lines += &quot;\t\t\t\t[\n&quot;
            for chord in voice[0]:
                lines += &quot;\t\t\t\t\t[\n&quot;
                if isinstance(chord, list):
                    for _ in chord:
                        if _ == &quot;Rest()&quot;:
                            lines += f&quot;\t\t\t\t\t\t{_},\n&quot;
                        else:
                            if _[0] == &quot;[&quot;:
                                lines += f&quot;\t\t\t\t\t\t{_[2:-2]},\n&quot;
                            else:
                                lines += f&quot;\t\t\t\t\t\t{_},\n&quot;
                else:
                    if chord == &quot;Rest()&quot;:
                        lines += f&quot;\t\t\t\t\t\t{chord},\n&quot;
                    else:
                        if chord[0] == &quot;[&quot;:
                            lines += f&quot;\t\t\t\t\t\t{chord[2:-2]},\n&quot;
                        else:
                            lines += f&quot;\t\t\t\t\t\t{chord},\n&quot;
                lines += &quot;\t\t\t\t\t],\n&quot;
            lines += &quot;\t\t\t\t],\n&quot;
            lines += &quot;\t\t\t),\n&quot;
            lines += &quot;\t\t\t\\dur, Pseq(\n\t\t\t\t[\n&quot;
            for dur in voice[1]:
                lines += f&quot;\t\t\t\t\t{quicktions.Fraction(dur) * 4} * {quicktions.Fraction(60, self.tempo[-1])},\n&quot;
            lines += &quot;\t\t\t\t]\n&quot;
            lines += &quot;\t\t\t,1),\n&quot;
            lines += &quot;\t\t\t\\legato, 1,\n\t\t).play;&quot;

        lines += &quot;)&quot;

        with open(
            f&#39;{self.current_directory}/voice_to_sc_{str(datetime.datetime.now()).replace(&quot; &quot;, &quot;-&quot;).replace(&quot;:&quot;, &quot;-&quot;).replace(&quot;.&quot;, &quot;-&quot;)}.scd&#39;,
            &quot;w&quot;,
        ) as fp:
            fp.writelines(lines)

<div class="viewcode-block" id="SegmentMaker.build_segment"><a class="viewcode-back" href="../../api/evans/segmentmaker.html#evans.segmentmaker.SegmentMaker.build_segment">[docs]</a>    def build_segment(self):
        with abjad.Timer() as timer:
            self._make_global_context()
        self.pre_handlers_time = int(timer.elapsed_time)
        with abjad.Timer() as timer:
            self._call_commands()
        self.handlers_time = int(timer.elapsed_time)
        with abjad.Timer() as timer:
            if self.mm_rests:
                self._make_mm_rests()
            self._add_attachments()
            self._cache_persistent_info()
            self._remove_final_grand_pause()
            self._extract_parts()
            self._break_pages()
            self._render_file()
        self.post_handlers_time = int(timer.elapsed_time)
        self._write_optimization_log()</div></div>


<div class="viewcode-block" id="beam_meter"><a class="viewcode-back" href="../../api/evans/segmentmaker.html#evans.segmentmaker.beam_meter">[docs]</a>def beam_meter(components, meter, offset_depth, include_rests=True):
    r&quot;&quot;&quot;

    .. container:: example

        &gt;&gt;&gt; pre_tuplet_notes = abjad.Staff(&quot;c&#39;8 c&#39;8 c&#39;8&quot;)
        &gt;&gt;&gt; tuplet = abjad.Tuplet((2, 3), &quot;c&#39;8 r8 c&#39;8&quot;)
        &gt;&gt;&gt; post_tuplet_notes = abjad.Staff(&quot;c&#39;8 c&#39;8 c&#39;8&quot;)
        &gt;&gt;&gt; staff = abjad.Staff()
        &gt;&gt;&gt; for _ in [pre_tuplet_notes[:], tuplet, post_tuplet_notes[:]]:
        ...     staff.append(_)
        ...
        &gt;&gt;&gt; evans.beam_meter(components=staff[:], meter=abjad.Meter((4, 4)), offset_depth=1)
        &gt;&gt;&gt; score = abjad.Score([staff])
        &gt;&gt;&gt; moment = &quot;#(ly:make-moment 1 25)&quot;
        &gt;&gt;&gt; abjad.setting(score).proportional_notation_duration = moment
        &gt;&gt;&gt; file = abjad.LilyPondFile(
        ...     items=[score],
        ...     includes=[&quot;abjad.ily&quot;],
        ...     global_staff_size=16,
        ... )
        ...
        &gt;&gt;&gt; abjad.show(file) # doctest: +SKIP

        .. docs::

            &gt;&gt;&gt; print(abjad.lilypond(staff))
            \new Staff
            {
                \override Staff.Stem.stemlet-length = 0.75
                c&#39;8
                [
                \revert Staff.Stem.stemlet-length
                c&#39;8
                ]
                c&#39;8
                \times 2/3 {
                    \override Staff.Stem.stemlet-length = 0.75
                    c&#39;8
                    [
                    r8
                    \revert Staff.Stem.stemlet-length
                    c&#39;8
                    ]
                }
                c&#39;8
                \override Staff.Stem.stemlet-length = 0.75
                c&#39;8
                [
                \revert Staff.Stem.stemlet-length
                c&#39;8
                ]
            }

    &quot;&quot;&quot;
    offsets = meter.depthwise_offset_inventory[offset_depth]
    offset_pairs = []
    for i, _ in enumerate(offsets[:-1]):
        offset_pair = [offsets[i], offsets[i + 1]]
        offset_pairs.append(offset_pair)
    initial_offset = abjad.get.timespan(components[0]).start_offset
    for i, pair in enumerate(offset_pairs):
        for i_, item in enumerate(pair):
            offset_pairs[i][i_] = item + initial_offset
    offset_timespans = [
        abjad.Timespan(start_offset=pair[0], stop_offset=pair[1])
        for pair in offset_pairs
    ]

    tup_list = [tup for tup in abjad.select(components).components(abjad.Tuplet)]
    for t in tup_list:
        if isinstance(abjad.get.parentage(t).components[1], abjad.Tuplet) is False:
            abjad.beam(
                t[:],
                beam_rests=include_rests,
                stemlet_length=0.75,
                beam_lone_notes=False,
                selector=abjad.select().leaves(grace=False),
            )
        else:
            continue

    non_tup_list = []
    for leaf in abjad.select(components).leaves():
        if isinstance(abjad.get.parentage(leaf).components[1], abjad.Tuplet) is False:
            non_tup_list.append(leaf)

    beamed_groups = []
    for i in enumerate(offset_timespans):
        beamed_groups.append([])

    for i, span in enumerate(offset_timespans):
        for group in (
            abjad.select(non_tup_list[:])
            .leaves()
            .group_by(
                predicate=lambda x: abjad.get.timespan(x).happens_during_timespan(span)
            )
        ):
            if abjad.get.timespan(group).happens_during_timespan(span) is True:
                beamed_groups[i].append(group[:])

    for subgroup in beamed_groups:
        subgrouper = abjad.select(subgroup).group_by_contiguity()
        for beam_group in subgrouper:
            # if not all(isinstance(leaf, abjad.Rest) for leaf in beam_group)
            abjad.beam(
                beam_group[:],
                beam_rests=include_rests,
                stemlet_length=0.75,
                beam_lone_notes=False,
                selector=abjad.select().leaves(grace=False),
            )</div>


<div class="viewcode-block" id="annotate_leaves"><a class="viewcode-back" href="../../api/evans/segmentmaker.html#evans.segmentmaker.annotate_leaves">[docs]</a>def annotate_leaves(score, prototype=abjad.Leaf):
    for voice in abjad.select(score).components(abjad.Voice):
        if prototype is not None:
            abjad.Label(voice).with_indices(prototype=prototype)
        else:
            abjad.Label(voice).with_indices()</div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2018-2021, Gregory Rowland Evans
      <span class="lastupdated">
        Last updated on Jun 03, 2021.
      </span>

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>